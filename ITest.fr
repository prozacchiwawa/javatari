--- Demonstration of terminal input/output
module examples.ITest where

import Prelude.PreludeArrays
import Test.QuickCheck

data Instruction = native org.javatari.general.m6502.Instruction where
     pure native fetch :: Instruction -> Int
     pure native toString :: Instruction -> String

data M6502 = native org.javatari.general.m6502.M6502 where
     pure native next :: M6502 -> M6502
     pure native getInstructionSources :: M6502 -> JArray String
     pure native withBus :: M6502 -> Trick2600 -> M6502
     pure native getCurrentBus :: M6502 -> Trick2600
     pure native getCurrentInstruction :: M6502 -> Instruction
     pure native printState :: M6502 -> String
     pure native setInput :: M6502 -> Int -> M6502
     pure native getPC :: M6502 -> Int
     pure native new :: () -> M6502

data Trick2600 = native org.javatari.general.board.Trick2600 where
     pure native getReads :: Trick2600 -> JArray Int
     pure native getWrites :: Trick2600 -> JArray Int
     pure native readByte :: Trick2600 -> Int -> Byte
     pure native new :: String -> Trick2600

formatReadsInner :: Int -> Int -> JArray Int -> String
formatReadsInner n l a =
    if n == l - 1 then
        show (elemAt a n)
    else
        (show (elemAt a n)) ++ ", " ++ (formatReadsInner (n + 1) l a)
                        
formatReads :: JArray Int -> String
formatReads a =
    let l = arrayLength a in
    if l == 0 then
        "[]"
    else
        "[" ++ (formatReadsInner 0 l a) ++ "]"

formatRegsInner :: [String] -> String
formatRegsInner l =
   case l of
     [] -> ""
     hd : tl ->
           let rest = formatRegsInner tl in
           if rest /= "" then
               hd ++ ", " ++ rest
           else
               hd

formatRegs l =
    "[" ++ (formatRegsInner l) ++ "]"

formatInstruction :: M6502 -> String
formatInstruction cpu =
    let i = M6502.getCurrentInstruction cpu in
    let bus = M6502.getCurrentBus cpu in
    let reads = Trick2600.getReads bus in
    let writes = Trick2600.getWrites bus in
    let isrc =
            filter ((/=) "") (listFromArray (M6502.getInstructionSources cpu))
    in
    (M6502.printState cpu) ++ " " ++ (Instruction.toString i) ++ " " ++ (formatReads reads) ++ " " ++ (formatReads writes) ++ " " ++ (formatRegs isrc)

doPreamble cpu =
    let bus = M6502.getCurrentBus cpu in
    let reads = listFromArray (Trick2600.getReads bus) in
    if reads == [640] then -- We read the joystick port
        cpu
    else
        doPreamble (M6502.next cpu)

doFrame cpu =
    let bus = M6502.getCurrentBus cpu in
    let reads = listFromArray (Trick2600.getReads bus) in
    if reads == [640] then -- Read js port
        do
          pure (False, cpu)
    else
        do
          --stdout.print $ (M6502.printState cpu) ++ "\n"
          doFrame (M6502.next cpu)

tach = 0xa8
speed = 0xb1

test =
    [
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     0,
     1,
     3,
     0,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     3,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     1,
     2,
     2,
     2,
     2,
     2,
     3,
     2,
     2,
     2,
     2,
     2,
     2,
     2,
     3,
     2,
     2,
     2,
     2,
     2,
     2,
     2,
     3,
     2,
     2,
     2,
     2,
     2,
     2,
     2,
     3,
     2,
     2,
     2,
     2,
     2,
     2,
     2,
     3,
     2,
     2,
     2,
     2,
     2,
     2,
     2,
     3
    ]

mapInput i =
    case i of
      0 -> 0xffffff
      1 -> 0xffff7f
      2 -> 0xbfffff
      _ -> 0xbfff7f

-- $8D <- race start countdown
      
known endbus n =
    let row a =
            [ (Trick2600.readByte endbus (a + 0)),
              (Trick2600.readByte endbus (a + 1)),
              (Trick2600.readByte endbus (a + 2)),
              (Trick2600.readByte endbus (a + 3)),
              (Trick2600.readByte endbus (a + 4)),
              (Trick2600.readByte endbus (a + 5)),
              (Trick2600.readByte endbus (a + 6)),
              (Trick2600.readByte endbus (a + 7)),
            ]
    in
    "Speed " ++ (show (Trick2600.readByte endbus (0xa8 + n))) ++ "\n" ++
    "Timer " ++ (show (Trick2600.readByte endbus (0xb3 + n))) ++ "-" ++
        (show (Trick2600.readByte endbus (0xb5 + n))) ++ "-" ++
        (show (Trick2600.readByte endbus (0xb7 + n))) ++ "\n" ++
    "Tach " ++ (show (Trick2600.readByte endbus (0xa8 + n))) ++ "\n" ++
    "Position " ++ (show (Trick2600.readByte endbus (0xba + n))) ++ "-" ++ (show (Trick2600.readByte endbus (0xc2 + n))) ++ "\n" ++
    "Row " ++ (show (row 0x80)) ++ "\n" ++
    "Row " ++ (show (row 0x88)) ++ "\n" ++
    "Row " ++ (show (row 0x90)) ++ "\n" ++
    "Row " ++ (show (row 0x98)) ++ "\n" ++
    "Row " ++ (show (row 0xa0)) ++ "\n" ++
    "Row " ++ (show (row 0xa8)) ++ "\n" ++
    "Row " ++ (show (row 0xb0)) ++ "\n" ++
    "Row " ++ (show (row 0xb8)) ++ "\n" ++
    "Row " ++ (show (row 0xc0)) ++ "\n" ++
    "Row " ++ (show (row 0xc8)) ++ "\n" ++
    "Row " ++ (show (row 0xd0)) ++ "\n" ++
    "Row " ++ (show (row 0xd8))

doOneFrame v cpu =
    do
      (reset,endcpu) <- doFrame (M6502.setInput (M6502.next cpu) v)
      endbus <- pure $ M6502.getCurrentBus endcpu
      win <- pure $ (Byte.unsigned (Trick2600.readByte endbus 0xba)) >= 97
      lose <- pure $ Byte.unsigned (Trick2600.readByte endbus (0xa8)) >= 32
      stdout.print $ "Input " ++ (Int.toHexString v) ++ "\n"
      stdout.print $ (M6502.printState endcpu) ++ "\n"
      stdout.print $ (known endbus 0) ++ "\n"
      pure (win || lose || reset,endcpu)
      
doFrames n inputs cpu =
    case inputs of
      hd : tl ->
          do
            stdout.print $ "Frame " ++ (show n) ++ "\n"
            (reset,fcpu) <- doOneFrame hd cpu
            if reset then
                pure fcpu
            else
                doFrames (n + 1) tl fcpu
      [] ->
          do
            pure cpu

quiet = 0xffffff
jsLeft = 0xbfffff
jsRight = 0x7fffff
button = 0xffff7f
buttonLeft = 0xbfff7f
reset = 0xfffeff

double t =
    case t of
      x : xs -> x : x : (double xs)
      [] -> []
        
times n v = if n == 0 then [] else (v : (times (n-1) v))
inputs =
    (times 2 jsRight) ++ (times 160 quiet) ++ (double (map mapInput test))
            
main _ =
    let trick = Trick2600.new "snoop/Dragster.bin" in
    let cpu = M6502.setInput (M6502.withBus (M6502.new ()) trick) quiet in
    do
      ncpu <- doFrames 0 inputs (doPreamble (M6502.next cpu))
      stdout.print $ "end-cpu " ++ (M6502.printState ncpu) ++ "\n"
