--- Demonstration of terminal input/output
module examples.IExpr where

import Prelude.PreludeArrays
import Test.QuickCheck
import Data.TreeMap (TreeMap, insert, lookup)
    
data Instruction = native org.javatari.general.m6502.Instruction where
     pure native fetch :: Instruction -> Int
     pure native getName :: Instruction -> String
     pure native toString :: Instruction -> String

data M6502 = native org.javatari.general.m6502.M6502 where
     pure native next :: M6502 -> M6502
     pure native getInstructionSources :: M6502 -> JArray String
     pure native getReads :: M6502 -> JArray Int
     pure native getWrites :: M6502 -> JArray Int
     pure native withBus :: M6502 -> Trick2600 -> M6502
     pure native getCurrentBus :: M6502 -> Trick2600
     pure native getCurrentInstruction :: M6502 -> Instruction
     pure native printState :: M6502 -> String
     pure native setInput :: M6502 -> Int -> M6502
     pure native getPC :: M6502 -> Int
     pure native futures :: M6502 -> JArray M6502
     pure native new :: () -> M6502

data Trick2600 = native org.javatari.general.board.Trick2600 where
     pure native readByte :: Trick2600 -> Int -> Byte
     pure native new :: String -> Trick2600

data Expr
    = Const Int
    | BitSet Int Expr
    | IsZero Expr
    | Instr String [(Int,Expr)] [(String,Expr)]
    | Plus Expr Expr
    | Rom Int
    | AND Expr Expr
    | Neg Expr
    | Borrow Expr
    | LSR Expr
    | XOR Expr Expr
    | ADC Expr Expr Expr
    | ASL Expr
    | PrevFrame
      
derive Show Expr

data RegName = A | X | Y | N | Z | V | C | D
derive Show RegName
derive Eq RegName
       
data CPU =
    CPU
    { a :: Expr
    , x :: Expr
    , y :: Expr
    , n :: Expr
    , z :: Expr
    , v :: Expr
    , c :: Expr
    , d :: Expr
    }
derive Show CPU

data Mem2 a =
    Mem2
    { x0 :: a
    , x1 :: a
    , x2 :: a
    , x3 :: a
    , x4 :: a
    , x5 :: a
    , x6 :: a
    , x7 :: a
    , x8 :: a
    , x9 :: a
    , xa :: a
    , xb :: a
    , xc :: a
    , xd :: a
    , xe :: a
    , xf :: a
    }
derive Show (Mem2 a)
          
type Mem = Mem2 (Mem2 Expr)

data Desc = Desc { mem :: Mem, cpu :: CPU, sta :: [String] }
derive Show Desc

(&) x f = f x
infixl 15 `&`
    
formatReadsInner :: Int -> Int -> JArray Int -> String
formatReadsInner n l a =
    if n == l - 1 then
        show (elemAt a n)
    else
        (show (elemAt a n)) ++ ", " ++ (formatReadsInner (n + 1) l a)
                        
formatReads :: JArray Int -> String
formatReads a =
    let l = arrayLength a in
    if l == 0 then
        "[]"
    else
        "[" ++ (formatReadsInner 0 l a) ++ "]"

formatRegsInner :: [String] -> String
formatRegsInner l =
   case l of
     [] -> ""
     hd : tl ->
           let rest = formatRegsInner tl in
           if rest /= "" then
               hd ++ ", " ++ rest
           else
               hd

formatRegs l =
    "[" ++ (formatRegsInner l) ++ "]"

formatInstruction :: M6502 -> String
formatInstruction cpu =
    let i = M6502.getCurrentInstruction cpu in
    let name = Instruction.getName i in
    let bus = M6502.getCurrentBus cpu in
    let reads = M6502.getReads cpu in
    let writes = M6502.getWrites cpu in
    let isrc =
            filter ((/=) "") (listFromArray (M6502.getInstructionSources cpu))
    in
    (M6502.printState cpu) ++ " " ++ name ++ " " ++ (formatReads reads) ++ " " ++ (formatReads writes) ++ " " ++ (formatRegs isrc)

doFrame cpu =
    let bus = M6502.getCurrentBus cpu in
    let reads = listFromArray (M6502.getReads cpu) in
    if reads == [640] then -- Read js port
          (False, cpu)
    else
          doFrame (M6502.next cpu)

nonempty a = a /= ""

startMem2 =
    Mem2
    { x0 = Const 0
    , x1 = Const 0
    , x2 = Const 0
    , x3 = Const 0
    , x4 = Const 0
    , x5 = Const 0
    , x6 = Const 0
    , x7 = Const 0
    , x8 = Const 0
    , x9 = Const 0
    , xa = Const 0
    , xb = Const 0
    , xc = Const 0
    , xd = Const 0
    , xe = Const 0
    , xf = Const 0
    }
startMem =
    Mem2
    { x0 = startMem2
    , x1 = startMem2
    , x2 = startMem2
    , x3 = startMem2
    , x4 = startMem2
    , x5 = startMem2
    , x6 = startMem2
    , x7 = startMem2
    , x8 = startMem2
    , x9 = startMem2
    , xa = startMem2
    , xb = startMem2
    , xc = startMem2
    , xd = startMem2
    , xe = startMem2
    , xf = startMem2
    }
startCpu =
    CPU
    { a = Const 0
    , x = Const 0
    , y = Const 0
    , n = Const 0
    , z = Const 0
    , v = Const 0
    , c = Const 0
    , d = Const 0
    }

startupExprs = Desc { mem = startMem, cpu = startCpu, sta = [] }

getA CPU { a = v, x = _, y = _, n = _, z = _, v = _, c = _, d = _ } = v
getX CPU { a = _, x = v, y = _, n = _, z = _, v = _, c = _, d = _ } = v
getY CPU { a = _, x = _, y = v, n = _, z = _, v = _, c = _, d = _ } = v
getN CPU { a = _, x = _, y = _, n = v, z = _, v = _, c = _, d = _ } = v
getZ CPU { a = _, x = _, y = _, n = _, z = v, v = _, c = _, d = _ } = v
getV CPU { a = _, x = _, y = _, n = _, z = _, v = v, c = _, d = _ } = v
getC CPU { a = _, x = _, y = _, n = _, z = _, v = _, c = v, d = _ } = v
getD CPU { a = _, x = _, y = _, n = _, z = _, v = _, c = _, d = v } = v

getMem2 m (Mem2 { x0 = x0, x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5, x6 = x6, x7 = x7, x8 = x8, x9 = x9, xa = xa, xb = xb, xc = xc, xd = xd, xe = xe, xf = xf }) =
    case m of
      0 -> x0
      1 -> x1
      2 -> x2
      3 -> x3
      4 -> x4
      5 -> x5
      6 -> x6
      7 -> x7
      8 -> x8
      9 -> x9
      10 -> xa
      11 -> xb
      12 -> xc
      13 -> xd
      14 -> xe
      x -> xf

getMem :: Int -> Mem -> Expr
getMem a mem =
    if a `mod` 8192 > 4096 then
        Rom a
    else
        getMem2 (a `mod` 16) (getMem2 (a `div` 16) mem)

setMem2 :: Int -> m -> Mem2 m -> Mem2 m
setMem2 m v mem =
    case m of
      0 -> Mem2 { x0 = v, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      1 -> Mem2 { x0 = getMem2 0x0 mem, x1 = v, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      2 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = v, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      3 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = v, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      4 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = v, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      5 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = v, x5 = v, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      6 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = v, x6 = v, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      7 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = v, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      8 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = v, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      9 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = v, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      10 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = v, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      11 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = v, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      12 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = v, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      13 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = v, xe = getMem2 0xe mem, xf = getMem2 0xf mem }
      14 -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = v, xf = getMem2 0xf mem }
      x -> Mem2 { x0 = getMem2 0x0 mem, x1 = getMem2 0x1 mem, x2 = getMem2 0x2 mem, x3 = getMem2 0x3 mem, x4 = getMem2 0x4 mem, x5 = getMem2 0x5 mem, x6 = getMem2 0x6 mem, x7 = getMem2 0x7 mem, x8 = getMem2 0x8 mem, x9 = getMem2 0x9 mem, xa = getMem2 0xa mem, xb = getMem2 0xb mem, xc = getMem2 0xc mem, xd = getMem2 0xd mem, xe = getMem2 0xe mem, xf = v }

setMem :: Int -> Expr -> Mem -> Mem
setMem m v mem =
    let m2 = setMem2 (m `mod` 16) v (getMem2 (m `div` 16) mem) in
    setMem2 (m `div` 16) m2 mem

exprOfCPU nm (CPU { a = a, x = x, y = y, n = n, z = z, v = v, c = c, d = d }) =
    case nm of
      "A" -> a
      "X" -> x
      "Y" -> y
      "N" -> n
      "Z" -> z
      "V" -> v
      "C" -> c
      _   -> d

cpuWithExpr :: String -> Expr -> CPU -> CPU
cpuWithExpr nm v cpu =
    case nm of
      "A" -> CPU { a = v, x = getX cpu, y = getY cpu, n = getN cpu, z = getZ cpu, v = getV cpu, c = getC cpu, d = getD cpu }
      "X" -> CPU { a = getA cpu, x = v, y = getY cpu, n = getN cpu, z = getZ cpu, v = getV cpu, c = getC cpu, d = getD cpu }
      "Y" -> CPU { a = getA cpu, x = getX cpu, y = v, n = getN cpu, z = getZ cpu, v = getV cpu, c = getC cpu, d = getD cpu }
      "N" -> CPU { a = getA cpu, x = getX cpu, y = getY cpu, n = v, z = getZ cpu, v = getV cpu, c = getC cpu, d = getD cpu }
      "Z" -> CPU { a = getA cpu, x = getX cpu, y = getY cpu, n = getN cpu, z = v, v = getV cpu, c = getC cpu, d = getD cpu }
      "V" -> CPU { a = getA cpu, x = getX cpu, y = getY cpu, n = getN cpu, z = getZ cpu, v = v, c = getC cpu, d = getD cpu }
      "C" -> CPU { a = getA cpu, x = getX cpu, y = getY cpu, n = getN cpu, z = getZ cpu, v = getV cpu, c = v, d = getD cpu }
      "D" -> CPU { a = getA cpu, x = getX cpu, y = getY cpu, n = getN cpu, z = getZ cpu, v = getV cpu, c = getC cpu, d = v }
      _   -> cpu

readSource :: Char -> String -> [String]
readSource m r =
    if String.charAt r 0 == m then
        [substr r 1 (String.length r)]
    else
        []

sources :: M6502 -> [String]
sources cpu =
    filter nonempty (listFromArray (M6502.getInstructionSources cpu))

m2l v =
    case v of
      Nothing -> []
      Just v -> [v]
           
genericToList a = map m2l (genericToMaybeList a) & concat

withSnd a b = (a,b)
                            
getNamedSource name reads ec =
    case reads of
      [] -> exprOfCPU name ec
      (n,v) : tl -> if n == name then v else getNamedSource name tl ec

readMemoryExprs :: Mem -> [Int] -> [(Int,Expr)]
readMemoryExprs em reads =
    map (\r -> (r,getMem r em)) reads

readRegisterExprs :: CPU -> [String] -> [(String,Expr)]
readRegisterExprs ec readSources =
    map (\r -> (r,exprOfCPU r ec)) readSources

applyIncrement :: Int -> Expr -> Expr
applyIncrement v e =
    case e of
      Const n -> Const (n+v)
      Plus n a -> Plus (applyIncrement 1 n) a
      e -> Plus (Const v) e
      
nc :: String -> CPU -> Mem -> [Int] -> [String] -> [String] -> CPU
nc name ec em reads readSources writeSources =
    let rme = readMemoryExprs em reads in
    let rre = readRegisterExprs ec readSources in
    getSourceForReg rme rre ec
    where
      doTransfer from into =
          let fromval = exprOfCPU from ec in
          ec &
             cpuWithExpr into fromval &
             cpuWithExpr "Z" (IsZero fromval) &
             cpuWithExpr "N" (BitSet 7 fromval)

      doLogical op from =
          let fromval = (op (exprOfCPU "A" ec) (getMem from em)) in
          ec &
             cpuWithExpr "A" fromval &
             cpuWithExpr "Z" (IsZero fromval) &
             cpuWithExpr "N" (BitSet 7 fromval)

      doBit from =
          let fromval = (AND (exprOfCPU "A" ec) (getMem from em)) in
          ec &
             cpuWithExpr "A" fromval &
             cpuWithExpr "Z" (IsZero fromval) &
             cpuWithExpr "N" (BitSet 7 fromval) &
             cpuWithExpr "V" (BitSet 6 fromval)

      doCPx from r =
          let val = Plus (exprOfCPU r ec) (Neg (getMem from em)) in
          ec &
             cpuWithExpr "N" (BitSet 7 val) &
             cpuWithExpr "Z" (IsZero val) &
             cpuWithExpr "C" (Borrow val)

      doShift op addr =
          case addr of
            Nothing ->
                let unshifted = exprOfCPU "A" ec in
                let shifted = op unshifted in
                ec &
                   cpuWithExpr "A" shifted &
                   cpuWithExpr "Z" (IsZero shifted) &
                   cpuWithExpr "C" (BitSet 0 unshifted)
            Just addr ->
                let unshifted = getMem addr em in
                let shifted = op unshifted in
                ec &
                   cpuWithExpr "Z" (IsZero shifted) &
                   cpuWithExpr "C" (BitSet 0 unshifted)

      doINC i r =
          let val = applyIncrement i (exprOfCPU r ec) in
          ec &
             cpuWithExpr r val &
             cpuWithExpr "N" (BitSet 7 val) &
             cpuWithExpr "Z" (IsZero val)

      doLDx reg addr =
          let val = getMem addr em in
          ec &
             cpuWithExpr reg val &
             cpuWithExpr "N" (BitSet 7 val) &
             cpuWithExpr "Z" (IsZero val)
                         
      getSourceForReg rme rre ec =
          case name of
            "AND" ->
                case reads of
                  [a] -> doLogical AND a
            "ASL" ->
                case (reads,readSources) of
                  ([],_) -> doShift ASL Nothing
                  ([addr],_) -> doShift ASL (Just addr)
            "BIT" ->
                case reads of
                  [a] -> doBit a
            "CPx" ->
                case (reads,readSources) of
                  ([a],reg : _) -> doCPx a reg
            "CLx" ->
                case writeSources of
                  [r] -> cpuWithExpr r (Const 0) ec
            "SEx" ->
                case writeSources of
                  [r] -> cpuWithExpr r (Const 1) ec
            "INx" ->
                case writeSources of
                  r : _ -> doINC 1 r
            "DEx" ->
                case writeSources of
                  r : _ -> doINC (-1) r
            "EOR" ->
                case reads of
                  [a] -> doLogical XOR a
            "LDx" ->
                case (writeSources,reads) of
                  (reg : _,[addr]) -> doLDx reg addr
            "LSR" ->
                case (reads,readSources) of
                  ([],_) -> doShift LSR Nothing
                  ([addr],_) -> doShift LSR (Just addr)
            "RTS" ->
                ec
            "STx" ->
                ec
            "JSR" ->
                ec
            "Txx" ->
                case (readSources,writeSources) of
                  (from : _, into : _) -> doTransfer from into
                                          
            _ ->
                foldr
                (\r ec -> cpuWithExpr r (Instr name rme rre) ec)
                ec
                writeSources

nm :: String -> CPU -> Mem -> [Int] -> [String] -> [Int] -> Mem
nm name ec em reads readSources writes =
    let rme = readMemoryExprs em reads in
    let rre = readRegisterExprs ec readSources in
    foldr (getSourceForWrite rme rre) em writes
    where
      doShift op addr =
          let unshifted = getMem addr em in
          let shifted = op unshifted in
          setMem addr shifted em
             
      getSourceForWrite rme rre r em =
          case name of
            "ASL" ->
                case reads of
                  [addr] -> doShift ASL addr
            "LDx" -> em
            "STx" ->
                case readSources of
                  reg : tl -> setMem r (exprOfCPU reg ec) em
                  _ -> setMem r (Instr ("?" ++ name ++ (show readSources)) rme rre) em
            "LSR" ->
                case reads of
                  [addr] -> doShift LSR addr
            _ ->
                setMem r (Instr name rme rre) em
          
doPreamble (Desc { mem = em, cpu = ec, sta = sta }) cpu =
    let pc = M6502.getPC () in
    let bus = M6502.getCurrentBus cpu in
    let reads = listFromArray (M6502.getReads cpu) in
    let writes = listFromArray (M6502.getWrites cpu) in
    let s = sources cpu in
    let readSources = s & (map (readSource 'r')) & concat in
    let writeSources = s & (map (readSource 'w')) & concat in
    let i = M6502.getCurrentInstruction cpu in
    let name = Instruction.getName i in
    let nnc = nc name ec em reads readSources writeSources in
    let nnm = nm name ec em reads readSources writes in
    let prereq = Desc { mem = nnm, cpu = nnc, sta = (formatInstruction cpu) : sta } in
    if reads == [640] then -- We read the joystick port
        (prereq, cpu)
    else
        let future = M6502.next cpu in -- genericToList (M6502.futures cpu) in
        doPreamble prereq future

-- $8D <- race start countdown
      
known endbus n =
    let row a =
            [ (Trick2600.readByte endbus (a + 0)),
              (Trick2600.readByte endbus (a + 1)),
              (Trick2600.readByte endbus (a + 2)),
              (Trick2600.readByte endbus (a + 3)),
              (Trick2600.readByte endbus (a + 4)),
              (Trick2600.readByte endbus (a + 5)),
              (Trick2600.readByte endbus (a + 6)),
              (Trick2600.readByte endbus (a + 7)),
            ]
    in
    "Timer " ++ (show (Trick2600.readByte endbus (0xb3 + n))) ++ "-" ++
        (show (Trick2600.readByte endbus (0xb5 + n))) ++ "-" ++
        (show (Trick2600.readByte endbus (0xb7 + n))) ++ "\n" ++
    "Position " ++ (show (Trick2600.readByte endbus (0xba + n))) ++ "-" ++ (show (Trick2600.readByte endbus (0xc2 + n))) ++ "\n" ++
    "80 " ++ (show (row 0x80)) ++ "\n" ++
    "88 " ++ (show (row 0x88)) ++ "\n" ++
    "90 " ++ (show (row 0x90)) ++ "\n" ++
    "98 " ++ (show (row 0x98)) ++ "\n" ++
    "a0 " ++ (show (row 0xa0)) ++ "\n" ++
    "a8 " ++ (show (row 0xa8)) ++ "\n" ++
    "b0 " ++ (show (row 0xb0)) ++ "\n" ++
    "b8 " ++ (show (row 0xb8)) ++ "\n" ++
    "c0 " ++ (show (row 0xc0)) ++ "\n" ++
    "c8 " ++ (show (row 0xc8)) ++ "\n" ++
    "d0 " ++ (show (row 0xd0)) ++ "\n" ++
    "d8 " ++ (show (row 0xd8))

doOneFrame v cpu =
      let (reset,endcpu) = doFrame (M6502.setInput (M6502.next cpu) v) in
      let endbus = M6502.getCurrentBus endcpu in
      let win = (Byte.unsigned (Trick2600.readByte endbus 0xba)) >= 97 in
      let lose = Byte.unsigned (Trick2600.readByte endbus (0xa8)) >= 32 in
      (win || lose || reset,endcpu)
      
doFrames n inputs cpu =
    case inputs of
      hd : tl ->
          let (reset,fcpu) = doOneFrame hd cpu in
          if reset then
              fcpu
          else
              doFrames (n + 1) tl fcpu
      [] ->
          cpu

quiet = 0xff0b80
jsLeft = 0xbf0b80
jsRight = 0x7f0b80
button = 0xff0b00
buttonLeft = 0xbf0b00
reset = 0xff0a80

printall l =
    case l of
      [] ->
          do
            pure ()
      hd : tl ->
          do
            stdout.print $ hd ++ "\n"
            printall tl
        
main _ =
    let trick = Trick2600.new "snoop/Dragster.bin" in
    let cpu = M6502.setInput (M6502.withBus (M6502.new ()) trick) quiet in
    let (Desc { cpu = cd, mem = md, sta = sta },c) =
            doPreamble startupExprs cpu
    in
    do
      printall (reverse sta)
      stdout.print $ "CPU\n" ++ (show cd) ++ "\nMEM\n" ++ (show md)
